#+title: org prettify meta lines
#+author: kinder rodrigues
#+email: ferraz.alkindar@gmail.com
#+property: header-args :comments yes :results silent :tangle "../init-files-c/org-pretty.el"
#+startup: overview
#+reveal_theme: night

* Objetivos
After seeing Rasmus' solution, which adds lines beginning with
~#+begin_src~ to ~prettify-symbols-alist~, I've decided to write my own.
Instead of ~prettify-symbols~, I've chosen ~font-lock~ itself for the job.

First a few variables and helper functions are defined, including a
list mapping org keywords to symbols. Then a font-lock rule, which
searches for lines starting with "#+". Based on the line contents, it
replaces the keywords for symbols. The details for finding the
replacement symbol are scattered across a few functions.

Next, to unprettify when point is at a replaced symbol, I've used the
same strategy as ~prettify-symbols-mode~:
- replaced symbols are marked with the start and end of the rplaced region
- when point is at symbol, check if it's display property
- if so, get start and end of region
- save these for later
- remove display prop
- when point leaves region, mark ir for refontification with ~font-lock-flush~

The level of fontification is given by ~k/org-fontify-level~
- simple: just ~#+~ keywords
- keywords: keywords in the rest of the line, starting with ~:~
- full: the entirety of the rest of the line.

There is a bug regarding this last one: The regex assumes there is a
word between ~#+ ... :~ keyword and the rest ~:keyords~, but a few
lines, such as
#+begin_example
#+options: tex:t toc:nil num:nil
#+end_example


will break ~tex~ and ~:t~, and replace just the later with the
appropriate symbol.


* Preps
These are for a prototype version, and I should rewrite the alist
#+begin_src elisp
(add-to-list 'font-lock-extra-managed-props 'display)
(defvar-local k/current-symbol-bounds nil)

(defvar k/org-fontification-level 'simple)
(setq k/org-fontification-level 'keywords)


(setq k/org-font-lock-symbols-alist
      '(("title"     . "")
        ("author"    . "")
        ("block"     . "")
        ("header"    . "")
        ("sql"       . "")
        ("tex"       . "")
        ("name"      . "")
        ("property"  . "")
        ("email"     . "")
        ("startup"   . "")
        ("setupfile" . "")
        ("reveal"    . "")
        ("date"      . "")
        ("caption"   . "")
        ("options"   . "" )

        ("src"       . "✎")
        ("quote"     . ("" ""))
        ("example"   . "")
        ("center"    . "")
        ("comment"   . "")
        ("export"    . "")
        ("verse"     . "")

        ("tangle"    . "")
        ("results"   . "")
        ("comments"  . "")
        ("label"     . "")

        ("engine"    . "")
        ("session"   . "")
        ("dbuser"    . "")
        ("dbhost"    . "")
        ("database"   . "")
        ("dbpassword" . "")

        ("latex" . "")
        ("sutitle" . "")
        ("class" . "")
        ("extra" . "")))


(defvar k/ob-header-symbol "☰")

(setq re "^[ \t]*\\(#\\+\\w*:?\\)\\(_\\w*:?\\)* ?\\([ \t[:alnum:]\"@,.-]*\\)\\(.*\\)$")


;; tudo que vem dps da palavra chave #+\w: é colocado num grupo, de la eu tento
;; separar?
;; TODO: refatorar a funcao de pegar simbolos:
;; aceitar apenas uma string, #+...: , sem os sinais, com _ no meio.
;; dar split nas keywords e
;; encontrar os simbolos com base na lista
;; "^[:blank:]*#\\+\\(\\w*_?\\w*\\):? ?\\([\t [:alnum:]\"@.-]*\\)\\([-.:,/{}\\\"[[:alnum:] ]*]*\\)$"
#+end_src


* Helpers
#+begin_src elisp
(define-inline chops (str)
  (->> str
      (downcase)
      (s-chop-prefixes '("#" "+" ":" "_"))
      (s-chop-suffixes '(":"))))

(defun get-prop-as-list (prop)
  "Helper: identify if char at point has PROP."
  (remove nil
          (list (get-text-property (point) prop)
                (when (and (eq prettify-symbols-unprettify-at-point 'right-edge)
                           (not (bobp)))
                  (get-text-property (1- (point)) prop)))))

(defun k/get-string-1 (first sec)
  "Find symbols associated with strings FIRST and SEC.
Returns them in approprate other."
  (let ((kw first) (sw sec) f-sym s-sym)
    (when (or (string= kw "begin")
              (string= kw "end"))
      (setq kw "block"))
    (setq f-sym (alist-get kw k/org-font-lock-symbols-alist
                           t nil #'string-equal ))
    (setq s-sym (alist-get sw k/org-font-lock-symbols-alist
                           t nil #'string-equal ))
    (when (listp s-sym)
      (if (string-equal first "begin")
          (setq s-sym (car s-sym))
        (setq s-sym (cadr s-sym))))
    (cond ((string-equal first "end")
           (concat s-sym f-sym))
          (t (concat f-sym s-sym)))))

(defun k/get-string (first &optional sec)
  "SEC is not always present. If so, return the symbol for FIRST.
Some other rules are defined here as well."
  (setq first (chops first))
  (cond ((string= "reveal" first)
         (alist-get first k/org-font-lock-symbols-alist
                    t nil #'string-equal ))
        ((> (length sec) 0)
         (k/get-string-1 first (chops sec)))
        (t
         (alist-get first k/org-font-lock-symbols-alist
                    t nil #'string-equal ))))
#+end_src


* Fontificar
#+begin_src emacs-lisp
(defun k/fontify-keywords (line-beg limit)
  "Fontify keywords starting with :, from LINE_BEG to LIMIT.
LIMIT should be the end of line."
  (save-excursion
    (goto-char line-beg)
    (while (re-search-forward ":\\w+" limit t)
      (let ((s (match-beginning 0))
            (e (match-end 0))
            (str (match-string 0)))
        (add-text-properties s e
                             `(display ,(k/get-string str)
                                       k/org-pretty-s ,s
                                       k/org-pretty-e ,e))))))

(defun k/fontify-symbols (limit)
  "Search for #+ lines, and replace them whit appropriated symbols.
If k/org-fontification-level is 'full, replace rest of line with symbol,
if it is 'keywords, pass rest of line to k/fontify-keywords.

Marks all replacements with beginning and end positions."
  (save-excursion
    (while (re-search-forward re limit t)
      (let* (pos)
        (if (match-end 2)
            (setq pos (cons (match-beginning 1) (match-end 2)))
          (setq pos (cons (match-beginning 1) (match-end 1))))
        (add-text-properties (car pos) (cdr pos)
                             `(display ,(k/get-string (match-string 1)
                                                      (match-string 2))
                               k/org-pretty-s ,(car pos)
                               k/org-pretty-e ,(cdr pos)))
        (when (match-string 4)
          (when (eq k/org-fontification-level 'full)
              (let* ((rest (list (match-beginning 4) (match-end 4))))
                (add-text-properties (car rest) (cadr rest)
                                     `(display ,k/ob-header-symbol
                                       k/org-pretty-s ,(car rest)
                                       k/org-pretty-e ,(cadr rest)))))
          (when (eq k/org-fontification-level 'keywords)
            (k/fontify-keywords (match-beginning 0)
                                (match-end 4))))))))
#+end_src


* Desesconder
#+begin_src emacs-lisp
(defun k/unfontify-current-symbol ()
  "When point is at a replaced symbols, remove display prop and save
bounds of symbol."
  (when-let* ((d (get-prop-as-list 'display))
              (s (get-prop-as-list 'k/org-pretty-s))
              (e (get-prop-as-list 'k/org-pretty-e))
              (s (apply #'min s))
              (e (apply #'max e)))
    (with-silent-modifications
      (setq k/current-symbol-bounds (list s e))
      (remove-text-properties s e '(display nil)))))

(defun k/refontify-current-symbol ()
  "When point is outside of region in k/current-symbol-bounds,
reapply fontification to region and unset region"
  (when (and k/current-symbol-bounds
	       (or (< (point) (car k/current-symbol-bounds))
		             (> (point) (cadr k/current-symbol-bounds))
		             (and (not (eq prettify-symbols-unprettify-at-point 'right-edge))
			                (= (point) (cadr k/current-symbol-bounds)))))
    (with-silent-modifications
      (font-lock-flush (car k/current-symbol-bounds)
                       (cadr k/current-symbol-bounds))
      (setq k/current-symbol-bounds nil))))

#+end_src


* Finalizando
#+begin_src emacs-lisp
;; use fontify rules
(font-lock-add-keywords
 'org-mode
 '((k/fontify-symbols))
 t)

;; use hook to unfontify and refontify symbols
(add-hook 'org-mode-hook
          '(lambda ()
             (add-hook 'post-command-hook #'k/unfontify-current-symbol nil t)
             (add-hook 'post-command-hook #'k/refontify-current-symbol nil t)))

(provide 'org-pretty)
#+end_src


* Scratch
In case of errors:
#+begin_src elisp :tangle no
;; Remove rules from alist and remove hook. In short, stop useing
;; everything in this file
(font-lock-remove-keywords
 nil
 '((k/fontify-symbols)
   (k/unfontify-current-line)))

(remove-hook 'post-command-hook #'k/unfontify-current-symbol t)
(remove-hook 'post-command-hook #'k/refontify-current-symbol t)

#+end_src
